<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kifu Viewer</title>
<style>
/* ページ全体の基本設定 */
body { 
  font-family: sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* 棋譜入力部分のコンテナ */
#sgf-container { 
  margin: 10px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

/* 棋譜入力テキストボックス */
#sgf-input { 
  font-size: 18px;
  width: 90vw;
  max-width: 800px;
}

/* 棋譜読み込み・クリアボタンのコンテナ */
#sgf-buttons { 
  display: flex;
  gap: 10px;
}

/* 棋譜ボタンのスタイル */
#sgf-buttons button { 
  font-size: 18px;
  padding: 5px 10px;
  cursor: pointer;
}

/* 座標表示用のテキストエリア */
#coords-display { 
  display: none !important;
  margin-top: 10px;
  font-family: monospace;
  word-break: break-all;
}

/* 移動操作ボタンのコンテナ */
#controls { 
  display: flex;
  justify-content: center;
  flex-wrap: nowrap;
  margin: 5px 0 10px 0;
  gap: 5px;
}

/* 各ナビゲーションボタン */
button.nav-btn {
  font-size: 18px;
  padding: 10px 15px;
  min-width: 50px;
  min-height: 45px;
}

/* iPad以上の画面用 */
@media (min-width: 768px) {
  button.nav-btn {
    font-size: 20px;
    padding: 15px 20px;
    min-width: 70px;
    min-height: 55px;
  }
}

/* 水色ボタン */
button.nav-btn.blue { 
  color: white;
  background-color: #00bfff;
}

/* 将棋盤・碁盤の描画用キャンバス */
canvas { 
  background-color: #F5C864;
  touch-action: manipulation;
  display: block;
}
</style>
</head>
<body>

<div id="sgf-container">
  <input type="text" id="sgf-input" placeholder="棋譜を貼ってください">
  <div id="sgf-buttons">
    <button id="load-sgf">読み込み</button>
    <button id="clear-sgf">クリア</button>
  </div>
</div>

<div id="coords-display"></div>

<canvas id="board"></canvas>

<div id="controls">
  <button class="nav-btn" id="first">|<</button>
  <button class="nav-btn blue" id="prev10"><<</button>
  <button class="nav-btn" id="prev1"><</button>
  <button class="nav-btn" id="next1">></button>
  <button class="nav-btn blue" id="next10">>></button>
  <button class="nav-btn" id="last">>|</button>
</div>

<script>
const BOARD_SIZE = 15;
const STAR_POINTS = [[3,3],[11,3],[3,11],[11,11],[7,7]];
let moves = [];
let currentMove = 0;
let inputText = '';

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const coordsDisplay = document.getElementById('coords-display');

function resizeCanvas(){
  const size = Math.min(window.innerWidth*0.95, 600);
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width = size+'px';
  canvas.style.height = size+'px';
  canvas.width = size*dpr;
  canvas.height = size*dpr;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
  redrawBoard();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --------------------
// パース関数
// --------------------
function parseSGF(sgfText){
  const regex = /[BW]\[([a-o]{2})\]/g;
  const result = [];
  let match;
  while((match=regex.exec(sgfText))!==null){
    let x=match[1].charCodeAt(0)-97;
    let y=match[1].charCodeAt(1)-97;
    result.push([x,y]);
  }
  return result;
}

function parseBFormat(bText){
  const mvIndex = bText.indexOf('mv=');
  let hex = mvIndex>=0 ? bText.slice(mvIndex+3) : bText;
  const startIndex = hex.indexOf('77');
  if(startIndex>=0) hex = hex.slice(startIndex);
  const coords = [];
  for(let i=0;i+1<hex.length;i+=2){
    const x = parseInt(hex[i],16);
    const y = parseInt(hex[i+1],16);
    if(!isNaN(x)&&!isNaN(y)) coords.push([x,y]);
  }
  return coords;
}

function parseCFormat(cText){
  const clean=cText.replace(/\s+/g,'');
  const regex=/([a-o])(\d{1,2})/ig;
  const result=[];
  let match;
  while((match=regex.exec(clean))!==null){
    const x=match[1].toLowerCase().charCodeAt(0)-97;
    const y=15-parseInt(match[2]);
    if(x>=0&&x<15&&y>=0&&y<15) result.push([x,y]);
  }
  return result;
}

function detectFormat(text){
  if(text.includes(";GM")) return "sgf";
  if(/^\s*\d+\)/m.test(text)) return "c2";
  if(/^[a-o][1-9]([0-9]?)([a-o][1-9]([0-9]?))*$/i.test(text.replace(/\s+/g,''))) return "c";
  if(text.includes("mv=")||/[0-9a-f]{2,}/i.test(text.replace(/\s+/g,''))) return "b";
  return "unknown";
}

function fromC2toC(input){
  const lines=input.split(/\r?\n/);
  let result="";
  for(let line of lines){
    const match=line.match(/^\s*\d+\)\s*([a-o]\d{1,2})/i);
    if(match) result+=match[1];
  }
  return result;
}

function parseInput(text){
  inputText = text;
  let format=detectFormat(text);
  if(format==="c2") text=fromC2toC(text), format="c";
  let parsed = [];
  if(format==="sgf") parsed = parseSGF(text);
  else if(format==="b") parsed = parseBFormat(text);
  else if(format==="c") parsed = parseCFormat(text);
  return parsed;
}

// --------------------
// URLパラメータで自動読み込み
// --------------------
function getQueryParam(name) {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get(name);
}

window.addEventListener('DOMContentLoaded', () => {
  let text = null;
  let format = null;

  if(getQueryParam('sgf')) {
    text = decodeURIComponent(getQueryParam('sgf'));
    format = 'sgf';
  } else if(getQueryParam('b')) {
    text = decodeURIComponent(getQueryParam('b'));
    format = 'b';
  } else if(getQueryParam('c')) {
    text = decodeURIComponent(getQueryParam('c'));
    format = 'c';
  }

  if(text && format) {
    let parsedMoves = [];
    if(format === 'sgf') parsedMoves = parseSGF(text);
    else if(format === 'b') parsedMoves = parseBFormat(text);
    else if(format === 'c') parsedMoves = parseCFormat(text);

    moves = parsedMoves;
    currentMove = moves.length;
    redrawBoard();
    document.getElementById('sgf-input').value = text;
  }
});

// --------------------
// 描画関数（修正版：3桁対応）
// --------------------
function redrawBoard(){
  const size = parseFloat(canvas.style.width);
  const margin = size * 0.07;
  const step = (size - 2 * margin) / (BOARD_SIZE - 1);
  ctx.clearRect(0, 0, size, size);

  // 盤線
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 1;
  for (let i = 0; i < BOARD_SIZE; i++) {
    ctx.beginPath();
    ctx.moveTo(margin, margin + i * step);
    ctx.lineTo(size - margin, margin + i * step);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(margin + i * step, margin);
    ctx.lineTo(margin + i * step, size - margin);
    ctx.stroke();
  }

  // 星
  for (const [sx, sy] of STAR_POINTS) {
    const cx = margin + sx * step;
    const cy = margin + (BOARD_SIZE - 1 - sy) * step;
    ctx.beginPath();
    ctx.arc(cx, cy, step * 0.12, 0, Math.PI * 2);
    ctx.fillStyle = 'black';
    ctx.fill();
  }

  // 座標文字
  ctx.fillStyle = 'black';
  ctx.font = `${step * 0.45}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (let i = 0; i < BOARD_SIZE; i++) {
    const x = margin + i * step;
    const y = size - margin / 2;
    ctx.fillText(String.fromCharCode(97 + i), x, y);
  }
  for (let i = 0; i < BOARD_SIZE; i++) {
    const x = margin / 2;
    const y = margin + (BOARD_SIZE - 1 - i) * step;
    ctx.fillText((i + 1).toString(), x, y);
  }

  // 石と手数
  const radius = step * 0.43;
  for (let i = 0; i < currentMove; i++) {
    const [x, y] = moves[i];
    const cx = margin + x * step;
    const cy = margin + y * step;
    const color = i % 2 === 0 ? 'black' : 'white';

    // 石の描画
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fill();

    // 手数の描画（桁数で倍率調整）
    const moveNumber = i + 1;
    const digitCount = moveNumber.toString().length;
    let fontScale;
    switch (digitCount) {
      case 1:
      case 2:
        fontScale = 1.25;
        break;
      case 3:
        fontScale = 1.1;
        break;
      default:
        fontScale = 0.75;
        break;
    }

    ctx.fillStyle = (i === currentMove - 1) ? 'red' : (color === 'black' ? 'white' : 'black');
    ctx.font = `bold ${radius * fontScale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(moveNumber, cx, cy);
  }

  // 内部座標表示用
  let displayStr = '';
  for (const [x, y] of moves) {
    displayStr += x.toString(16) + y.toString(16);
  }
  coordsDisplay.textContent = displayStr;
}

// --------------------
// 移動関数
// --------------------
function gotoMove(n){
  currentMove = Math.max(0, Math.min(n, moves.length));
  redrawBoard();
}

// --------------------
// ボタンイベント
// --------------------
document.getElementById('load-sgf').addEventListener('click',()=>{
  const text=document.getElementById('sgf-input').value;
  if(!text) return;
  moves=parseInput(text);
  currentMove=moves.length;
  redrawBoard();
});

document.getElementById('clear-sgf').addEventListener('click',()=>{
  document.getElementById('sgf-input').value='';
  moves=[];
  currentMove=0;
  coordsDisplay.textContent = '';
  redrawBoard();
});

document.getElementById('first').addEventListener('click',()=>gotoMove(0));
document.getElementById('prev1').addEventListener('click',()=>gotoMove(currentMove-1));
document.getElementById('prev10').addEventListener('click',()=>gotoMove(currentMove-10));
document.getElementById('next1').addEventListener('click',()=>gotoMove(currentMove+1));
document.getElementById('next10').addEventListener('click',()=>gotoMove(currentMove+10));
document.getElementById('last').addEventListener('click',()=>gotoMove(moves.length));
</script>

</body>
</html>
